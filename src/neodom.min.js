
class Parse {
	static TK_UNDEFINED = -1;
	static TK_KEYWORD = 0;
	static TK_INTEGER = 1;
	static TK_NUMBER = 2;
	static TK_SPECIAL = 3;
	static TK_STRING = 4;
	static TK_CHAR = 5;
	static TK_BOOL = 6;

	static ALPHA = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
	static DIGIT = "0123456789";

	static is_alpha(chr) {
		return Parse.ALPHA.indexOf(chr) > -1;
	}

	static is_digit(chr) {
		return Parse.DIGIT.indexOf(chr) > -1;
	}

	constructor(source) {
		this.source = source;
		this.token_type = Parse.TK_UNDEFINED;
		this.token_kind = null;
		this.source_index = 0;
		this.source_line = 0;
		this.source_column = 0;
		this.source_finished = false;

		this.historic_token_type = this.token_type;
		this.historic_token_kind = this.token_kind;
		this.historic_source_index = this.source_index;
		this.historic_source_finished = this.source_finished;

		this.historic = [];
	}

	restore() {
		let data = this.historic.pop();
		
		this.source_index = data[2];
		this.source_finished = data[3];
		this.token_kind = data[1];
		this.token_type = data[0];
	}

	next(ignore = []) {
		this.historic.push([
			this.token_type,
			this.token_kind,
			this.source_index,
			this.source_finished
		]);

		if (this.source.length < 1)
			this.source_finished = true;
		
		if (this.source_finished) {
			this.token_kind = null;
			this.token_type = Parse.TK_UNDEFINED;
			
			console.log("The current Parser is now finished!");
			
			return;
		}

		this.token_kind = null;
		this.token_type = Parse.TK_UNDEFINED;

		let to_next = true;

		while (to_next) {
			let chr = this.source[this.source_index];

			switch (this.token_type) {
				case Parse.TK_KEYWORD: {
					if (Parse.is_alpha(chr) || Parse.is_digit(chr) || chr == '_') {
						this.token_kind += chr;
						this.source_index++;
					}

					else {
						to_next = false;
					}

					break;
				}

				case Parse.TK_INTEGER: {
					if (Parse.is_digit(chr)) {
						this.token_kind += chr;
						this.source_index++;
					}

					else if (chr== '.') {
						this.token_kind += chr;
						this.token_type = Parse.TK_NUMBER;
						this.source_index++;
					}

					else if (chr == '_') {
						this.source_index++;
					}

					else {
						to_next = false;
					}

					break;
				}

				case Parse.TK_NUMBER: {
					if (Parse.is_digit(chr)) {
						this.token_kind += chr;
						this.source_index++;
					}

					else if (chr == '_') {
						this.source_index++;
					}

					else {
						to_next = false;
					}

					break;
				}

				case Parse.TK_STRING: {
					switch (chr) {
						case '"': {
							to_next = false;
							break;
						}

						default: {
							this.token_kind += chr;
							break;
						}
					}

					this.source_index++;
					break;
				}

				case Parse.TK_CHAR: {
					switch (chr) {
						case "'": {
							to_next = false;
							break;
						}

						default: {
							this.token_kind += chr;
							
							break;
						}
					}

					this.source_index++;
					break;
				}

				default: {
					if (Parse.is_alpha(chr) || chr == '_') {
						this.token_type = Parse.TK_KEYWORD;
						this.token_kind = chr;
					}

					else if (Parse.is_digit(chr)) {
						this.token_type = Parse.TK_INTEGER;
						this.token_kind = chr;
					}

					else {
						switch (chr) {
							case '"': {
								this.token_type = Parse.TK_STRING;
								this.token_kind = "";
								break;
							}

							case "'": {
								this.token_type = Parse.TK_CHAR;
								this.token_kind = "";
								break;
							}

							case ' ': {
								break;
							}

							default: {
								this.token_type = Parse.TK_SPECIAL;
								this.token_kind = chr;
								
								to_next = false;
								break;
							}
						}
					}

					this.source_index++;
					break;
				}
			}

			if (this.source_index >= this.source.length) {
				to_next = false;
				this.source_finished = true;
			}

			if (to_next == false) break;
		}

		// Token Kind Convertions

		if (this.token_kind != null) {
			switch (this.token_type) {
				case Parse.TK_INTEGER:
					this.token_kind = parseInt(this.token_kind);
					break;

				case Parse.TK_NUMBER:
					this.token_kind = parseFloat(this.token_kind);
					break;

				case Parse.TK_KEYWORD: {
					if (this.token_kind == 'true' || this.token_kind == 'false') {
						this.token_type = Parse.TK_BOOL;
						this.token_kind = this.token_kind === 'true';
					}

					break;
				}

				default:
					break;
			}
		}

		for (let i = 0; i < ignore.length; ++i) {
			let token = ignore[i];

			if (token instanceof Array) {
				if (token.length > 0) {
					if (this.token_type == token[0]) {
						if (token.length > 1) {
							if (token[1] == this.token_kind) {
								return this.next();
							}

							else continue;
						}

						return this.next();
					}

					else continue;
				}
			}
		}
	}
}

class Expression {
	constructor() {}
}

class Statement {
	constructor() {}
}

class ExpressionStatement {
	constructor() {}
}

class Identifier extends Expression {
	constructor(name) {
		super();

		this.name = name;
	}
}

class Literal extends Expression {
	constructor(literal) {
		super();

		this.literal = literal;
	}
}

class CallStatement extends ExpressionStatement {
	constructor(identifier, values = []) {
		super();

		this.identifier = identifier;
		this.values = values;
	}
}

class Unary extends Expression {
	constructor(signal, expression) {
		super();

		this.signal = signal;
		this.expression = expression;
	}
}

class BinOp extends Expression {
	constructor(signal, left, right) {
		super();

		this.signal = signal;
		this.left = left;
		this.right = right;
	}
}

class Operator {
	constructor(signal) {
		this.signal = signal;
	}
}

class State {
	/**
	 * @property {State} Singleton
	 **/

	static Singleton = null;

	constructor() {
		this._G = {};
		this._F = {};

		this.dom = null;
		this.failed = false;

		State.Singleton = this;
	}

	error(message = "Ocorred an Error") {
		this.failed = true;

		console.log(message);
	}
}

function neodom_exec(state, source, object) {
	if (state instanceof State) {
		if (object instanceof HTMLElement) {
			if (typeof source == 'string') {
				state.dom = object;

				var parse = new Parse(source);
				
				const ignore_tokens = [
					[Parse.TK_SPECIAL, '\n'],
					[Parse.TK_SPECIAL, '\r'],
					[Parse.TK_SPECIAL, '\t'],
				];
				const query_expression = (expressions = []) => {
					const precedences = {
						'+': 0,
						'-': 0,
						'*': 1,
						'/': 1,
						'%': 0,
					}

					let finded_all_unarys = false;

					const query_step = (list, precedence) => {
						let queue = [];

						let last_is_expr = (from) => {
							return (from.length > 0 &&
										((from[from.length - 1] instanceof Expression)
										||
										(from[from.length - 1] instanceof ExpressionStatement)));
						}

						
						for (let i = 0; i < list.length; ++i) {
							let expr = list[i];

							if (expr instanceof Operator) {
								if (finded_all_unarys == false) {
									if (expr instanceof Operator) {
										if (!last_is_expr(queue)) {
											switch (expr.signal) {
												case '+':
												case '-': {
													if (i + 1 < list.length && (list[i + 1] instanceof Expression
														|| list[i + 1] instanceof ExpressionStatement)) {
														queue.push(new Unary(expr.signal, list.splice(i + 1, 1)[0]));
													}

													else {
														state.error("Expected an Expression after Unary Operator!");
														return null;
													}

													break;
												}

												default: {
													queue.push(expr);
												}
											}
										}

										else queue.push(expr);
									}

									else queue.push(expr);
								}

								else {
									if (precedences[expr.signal] == precedence) {
										if (!last_is_expr(queue)) {
											state.error(
												'Expected an Expression before Operator "' + expr.signal + '"!');
											return null;
										}

										let binop = new BinOp(expr.signal, queue.pop(), null);

										if (i + 1 < list.length && (list[i + 1] instanceof Expression
											|| list[i + 1] instanceof ExpressionStatement)) {
											binop.right = list.splice(i + 1, 1)[0];
										}

										else {
											state.error("Expected an Expression after Binnary Operator!	");

											return null;
										}

										queue.push(binop);
									}
									
									else queue.push(expr);
								
								}	
								
							}

							else if (expr instanceof Expression) {
								if (expr instanceof Literal) {
									queue.push(expr);
								}

								else if (expr instanceof Identifier) {
									queue.push(expr);
								}

								else if (expr instanceof Unary) {
									queue.push(expr);
								}

								else if (expr instanceof BinOp) {
									queue.push(expr);
								}
							}

							else if (expr instanceof ExpressionStatement) {
								if (expr instanceof CallStatement) {
									queue.push(expr);
								}
							}
						}

						if (state.failed == true) {
							return null;
						}

						if (finded_all_unarys == false) {
							finded_all_unarys = true;
							return query_step(queue, precedence);
						}

						if (precedence > 0) {
							precedence -= 1;
							return query_step(queue, precedence);
						}

						else
							return queue.pop();
					}

					return query_step(expressions, 4);
				}
				const find_expression_statement = (stop_specials = [], expressions = []) => {
					if (parse.source_finished == true) return query_expression(expressions);

					parse.next(ignore_tokens);

					switch (parse.token_type) {
						case Parse.TK_STRING:
						case Parse.TK_CHAR:
						case Parse.TK_INTEGER:
						case Parse.TK_NUMBER: {
							if (expressions.length > 0 && !(expressions[expressions.length - 1] instanceof Operator)) {
								state.error("Expected an Operator before Literal '" + parse.token_kind + "'!");
								return null;
							}
							expressions.push(new Literal(parse.token_kind));
							return find_expression_statement(stop_specials, expressions);
						}

						case Parse.TK_SPECIAL: {
							if (stop_specials.indexOf(parse.token_kind) < 0) {
								switch (parse.token_kind) {
									case '+':
									case '-': 
									case '*':
									case '/':
									case '%': {
										expressions.push(new Operator(parse.token_kind));
										return find_expression_statement(stop_specials, expressions);
									}
								}
							}

							else
								return query_expression(expressions);

							break;
						}
							
						case Parse.TK_KEYWORD: {
							switch (parse.token_kind) {
								default: {
									if (expressions.length > 0
										&& !(expressions[expressions.length - 1] instanceof Operator)) {
											state.error(
												"Expected an Operator before CallStatement '" + parse.token_kind + "'!");
											return null;
									}
									let callable = new CallStatement();
									callable.identifier = new Identifier(parse.token_kind);
									callable.values = [];

									parse.next(ignore_tokens);

									//x.y.z()
									//(x.y).z()

									if (parse.token_type == Parse.TK_SPECIAL && parse.token_kind == '(') {
										while (!(parse.token_type == Parse.TK_SPECIAL && (parse.token_kind == ')'))) {
											if (state.failed == true) return null;

											let expr = find_expression_statement([',', ')'], []);

											if (expr) callable.values.push(expr);
										}
										
										expressions.push(callable);
										return find_expression_statement(stop_specials, expressions);
									}

									else {
										state.error("Expected an Token '('!");
									}
									
									break;
								}
							}
							break;
						}
					}

					return null;
				}

				let exec = (expression_statement) => {
					if (expression_statement instanceof BinOp) {
						switch (expression_statement.signal) {
							case '+': {
								return exec(expression_statement.left) + exec(expression_statement.right);
							}

							case '-': {
								return exec(expression_statement.left) - exec(expression_statement.right);
							}

							case '*': {
								return exec(expression_statement.left) * exec(expression_statement.right);
							}

							case '/': {
								return exec(expression_statement.left) / exec(expression_statement.right);
							}
						}
					}

					else if (expression_statement instanceof Unary) {
						switch (expression_statement.signal) {
							case '+': {
								return 0 - exec(expression_statement.expression);
							}

							case '-': {
								return 0 - exec(expression_statement.expression);
							}
						}
					}

					else if (expression_statement instanceof Identifier) {
						if (expression_statement.name in state._G) {
							return state._G[expression_statement.name];
						}

						else {
							state.error("Identifier is not founded in Global Context!");
						}
					}

					else if (expression_statement instanceof Literal) {
						return expression_statement.literal;
					}

					else if (expression_statement instanceof CallStatement) {
						if (expression_statement.identifier instanceof Identifier) {
							if (expression_statement.identifier.name in state._F) {
								if (state._F[expression_statement.identifier.name][1]
									== expression_statement.values.length) {
									let pre_executed = [];
									
									for (let i = 0; i < expression_statement.values.length; ++i) {
										pre_executed.push(exec(expression_statement.values[i]));
									}

									return state._F[expression_statement.identifier.name][0](...pre_executed);
								}

								else {
									state.error(
										`Expected just ${state._F[expression_statement.identifier.name][1]} arguments!`);
								}
							}

							else {
								state.error(`Function ${expression_statement.identifier.name} is not exists!`);
							}
						}
					}

					return null;
				}

				while (parse.source_finished == false) {
					if (state.failed == true) {
						break;
					}

					let expression_statement = find_expression_statement(['\n', ';'], []);

					if (expression_statement) {
						let res = exec(expression_statement);

						if (res) console.log('>>', res);
					}
				}
				
				state.dom = null;
			}
		}
	}

	return null;
}

function neodom_setup(state, object) {
	if (!(state instanceof State)) return null;

	if (object instanceof HTMLElement) {
		let source = object.className.substring(4);
		
		return neodom_exec(state, source, object);
	}
}

function neodom_init(state) {
	if (!(state instanceof State)) {
		state = new State();
		state._G['px'] = 0;
		state._G['em'] = 1;
	}
}

function neodom_start(state) {
	const main = document.querySelector('main');

	if (main instanceof HTMLElement) {
		const items = document.querySelectorAll('.neo');

		for (let object of items) {
			neodom_setup(state, object);
		}
	}
}

function neodom_func(state, funcname, argc, callable) {
	if (!(state instanceof State) || typeof funcname != 'string' || typeof argc != 'number' || callable == null)
		return null;

	state._F[funcname] = [callable, argc];
}

